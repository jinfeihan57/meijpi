[TOC]



# 改善程序与设计的55个具体做法

## 第一章 让自己习惯 C++



### 条款01：视C++为一个语言的联邦

### 条款02：尽量以const，enum，inline，替换 #define

### 条款03：尽可能使用const

### 条款04：确定对象被使用前已先被初始化

## 第二章 构造/析构/赋值运算



### 条款05：了解C++默默编写并调用那些函数

### 条款06：若不想使用编译器自动生成的函数，就该明确拒绝

### 条款07：为多态基类声明virtual析构函数

### 条款08：别让异常逃离析构函数

### 条款09：绝不再构造和析构过程调用virtual函数

### 条款10：令operator=返回一个reference to * this

### 条款11：在operator=中处理“自我赋值”

​		在使用对象管理资源（动态内存申请，文件描述符，互斥锁，数据库连接，网络socket连接，图形界面的字形和笔刷）时，要保证在资源copy时也能有正确的操作，需要对资源进行特殊的关注。而当这种管理资源的对象，进行operator=操作时。目标对象需要先释放资源，在使用来源对象的资源进行相关属性的初始化。如果目标对象和来源对象是同一个对象时则会出现，使用已经释放的来源对象属性来初始化目标对象属性，导致不可预知错误。

​		在指针和引用大量使用时，容易造成两个对象实际指向同一块内存。或者在多态中，即父类指针或者引用指向子类对象时，也是两个对象指向同一内存区域。极易造成，使用中无法准确判断是否自我赋值。

解决方案：

```c++
Widget& Widget::operator=(const Wiget &rhs){
	if(this == &rhs) return *this;  // 如果是自我赋值则直接返回
	// 否则正常赋值
	delete pb;
	pb = new Bitmap(*(rhs.pb));
	return *this;
}
```

​		上述方法中如果在new Bitmap中产生了异常则导致 pb指向的内存无法安全访问。

解决方案：

```c++
Widget& Widget::operator=(const Wiget &rhs){
	Bitmap *pOrig = pb;
	pb = new Bitmap(*(rhs.pb));
	delete pOrig;
	return *this;
}
```

​		这样在 new Bitmap异常时，pb指向的内存仍然为原来的指向。当然这样不管三七二十一先new一个对象会导致在自我赋值的情况下效率较低，因此可以和自我赋值测试语句联合使用。同样的增加的自我赋值检测只是为了在自我赋值时的效率提高，但是非自我赋值时的效率则会有所下降。因此同样要考虑自我赋值和非自我赋值发生的概率。整体来看，不加更好。

​		在operator=函数中使用 copy and swap 技术，可以更好的解决上述问题。详细用法可跳转条款29中查看 copy and swap 的使用。

以下代码展示：

```c++
class Widget{
	...
	void swap(Widget& rhs);  // 内部可调用 std::swap();
	...
}

Widget& Widget::operator=(const Wiget &rhs){
	Widget tmp（rhs);        // copy构造函数异常，则不会调用后续代码，不会改变 *this 对象。
	swap(tmp);
	return *this;
}

```

```c++
Widget& Widget::operator=(Wiget rhs){   // 采用值传递的方式可以避免 tmp 的创建，避免copy构造异常
	swap(rhs);
	return *this;
}
```

- [ ] 确保当对象自我赋值时 operator= 有良好的行为，其中技术包括比较“来源对象”和“目的对象”的地址，精心周到的语句顺序以及copy-and-swap.
- [ ] 确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。

### 条款12：赋值对象是勿忘其中每一个成分

## 第三章 资源管理

​		所谓资源就是，一旦用了它，将来一定要还给系统。如果不这样糟糕的事情就会发生。C++程序中最常用的资源就是动态内存分配，但是内存分配只是你必须管理的众多资源之一。其他常见的资源还包括问文件描述符，互斥锁，数据库连接，网络连接socket以及图形界面中的字形和笔刷。

### 条款13：以对象管理资源

​		当程序非正常返回或退出时（提前return，goto语句，continue，异常发生等），会造成资源泄露。我们将资源放进对象（auto_ptr 和 shared_ptr），当控制流离开函数时，该对象的析构函数会自动释放那些资源。

​		**获得资源后立即方剂对象内**：（RAII）

​		**管理对象运用析构函数确保资源被释放**：如果资源释放动作可能导致异常抛出，事情将棘手，参考条款8解决异常问题。

​		**使用智能指针对heap资源进行管理：**

​		1：auto_ptr ：在赋值后即会失去自己对对象的拥有权，拥有权转移到了新的指针对象上，自己变为了空指针。

​		2：shared_ptr：采用RCSP（Reference counting smart pointer）技术，shared_ptr允许指针对象赋值并且在无人指向时自动delete。不同的时RCSP无法打破环状引用，例如两个对象彼此互指。（需要使用weak_ptr来解决环状引用的问题）

​		auto_ptr和shared_ptr都是在其析构函数内做delete而不是delete[ ] 动作，因此这两个智能指针都不能在动态分配的array身上使用。

```c++
shared_ptr<int> spi(new int[10])   // 虽然编译器不会报错，但是这样做显然不对
```

针对数组型智能指针参见条款55中 boost::scoped_array 和boost::shared_array 类。

- [ ] 为防止资源泄露，请使用RAII（Resource Acquisition Is Initialization）对象，他们在构造函数中获得资源并在析构函数中释放资源。
- [ ] 两个常被使用的RAII class分别是 shared_ptr 和 auto_ptr，通常使用前者。

### 条款14：在资源管理类中小心copying行为

​		如果资源不是heap-based资源，auto_ptr和shared_ptr将不适合对这类资源进行管理。例如：

```c++
class Lock{
public:
    explicit Lock(Mutex *pm):mutexPtr(pm){
        lock(mutexPtr);
    }
    ~Lock(){ unlock(mutexPtr);}
private:
    Mutex *mutexPtr;
}

int fun(){
    ...
    Mutex m;		// 定义互斥器
    {
        Lock m1(&m);// 锁定互斥器 在大括号内有效
        ...
    }				
    ...				// 互斥器，自动解锁，m1 出生命区间自动析构解锁
}
```

​		禁止复制：许多时候RAII类资源被复制时不合理的，例如上面 Mutex 的例子。如果复制动作对RAII不合理，应该禁止它。参考条款06，将其声明到private域或者声明为delete。

​		对底层资源祭出“引用计数法”：有时候我们希望保有资源，直到最后一个使用者被销毁。这种情况下复制RAII对象，只是将资源的引用数递增。shared_ptr就是reference count实现的。通常只要内含一个shared_ptr即可，但是shared_ptr在引用为0时会删除所指物。例如在Mutex上我们只是希望它unlock而非delete。 幸运的是shared_ptr允许我们指定删除器，是一个函数或者仿函数。

```c++
class Lock{
public:
    explicit Lock(Mutex * const pm):mutexPtr(pm, unlock){  // 第二参数为智能指针引用为0时调用的delete函数。
        lock(mutexPtr.get());    
    }
private:
    shared_ptr<Mutex> mutexPtr;  // 采用智能指针而非普通指针
};
```

​		本例中 Lock class不在声明析构函数（编译器自动生成），因为没有必要。条款05:析构函数（编译器生成的）会自动调用其non-static成员变量的析构函数，这里mutexPtr的析构函数在引用计数到达0时被调用，而mutexPtr的析构函数被重定向为unlock。注解:上面代码中涉及两个对象，一个是Lock，另一个shared_ptr<Mutex>，Lock采用编译器默认的析构函数，而mutexPtr使用的析构函数为unlock。具体参见shared_ptr的构造函数第二参数。

​		复制底层资源：在复制资源管理对象时，进行深拷贝。例如 heap-based 资源。

​		转移底部资源的拥有权：即copy构造和copy复制函数会剥夺被复制物的资源控制权给目标。动作如auto_ptr。

- [ ] 复制RAII对象必须一起复制他所管理的资源，所以资源的copying行为决定RAII对象的copying行为。
- [ ] 普遍而常见的RAII class copying行为是：抑制copying、施行引用计数法（reference counting）。不过其他行为也都是可以被实现的。

### 条款15：

### 条款16：

### 条款17：

## 第四章

## 第五章 实现

### 条款26：

### 条款27：

### 条款28：

### 条款29：为“异常安全”而努力是值得的

异常被抛出时，带有异常安全性的函数会：

1，**不泄露任何资源**。尤其注意动态内存，互斥锁，文件描述符，socket链接，数据库链接等系统资源。

2，**不允许数据破坏**。在抛出异常后，函数不会破坏原有的数据，不会修改程序状态。

​		解决资源泄露的问题，可参考条款13如何以对象管理资源，条款14使用Lock class作为一种确保互斥器被及时释放的方法。构造函数上锁，离开作用域自动调用析构函数。

​		解决数据破坏的问题：

​		**基本保证**：如果异常被抛出，程序内的任何事物仍然保持在有效的状态下（不会出现无效属性）。没有任何对象或数据结构会因此而破坏，所以对象都处于一种内部前后一致的状态。例如，文件打开失败时，不会返回无效的文件描述符等。

​		**强烈保证**：如果异常被抛出，程序状态不改变。调用这样的函数，如果函数成功了，就是完全成功，如果失败了，就会回退到调用前状态。

​		基本承诺在异常时虽然，能保证数据合法，但是可能处于合法的任何一个状态，依然是不可控的。而强烈保证，在异常时则可以准确的知道程序数据的状态。是一种使用起来更容易的函数。

​		**不抛掷保证**：承诺绝不抛出异常，因为它们总是能够完成它们原先承诺的任务。

```c++
int doSomething() throw();				// 明确指明不会抛出异常
```

​		这并不是说doSomething绝不会抛出异常，而是说如果doSomething抛出异常，将会是严重错误，会有你意想不到的函数被调用。函数的声明式并不能够告诉你是否它是正确的、可以值的或者高效的，也不能告诉你它是否提供任何异常安全性保证。所有的那些性质都是由函数的实现决定，无关乎声明。



​		参考条款13可以采用智能指针shared_ptr来进行资源管理，调用shared_ptr的reset()函数，reset()函数只有在参数执行成功后才会被调用，在reset()函数内会对原来的指针进行delete。保证了 new class的成功。new 操作会调用内存申请，有机会产生 bad_alloc 异常。

​		copy and swap 的设计策略很典型地会导致强烈保证，其原则很简单：为你打算修改的对象作出副本，然后在那副本身上做一切必要修改。若有任何修改动作抛出异常，原对象扔保持未改变状态，待改变成功后再一个不抛出异常的操作值置换（swap）。

```c++
struct PMImpl{
    shared_ptr<Image> bgImage;
    int imageChanges;
};
class PrettyMenu{
    ...
private:
    Mutex mutex;
    shared_ptr<PMImpl> pImpl;
};
void PrettyMenu::changeBackground(std::istream &imgSrc){
    using std::swap;
    //采用对象锁 
    Lock ml(&mutex);
    //创造副本并且做必要修改
    shared_ptr<PMImpl> pNew(new PMImpl(*pImpl));
    pNew->bgImage.reset(new Image(imgSrc));
    pNew->imageChanges++;
    // 采用指针交换，指针交换不会对对象本体进行再次的构造和析构，只需要交换地址指针即可
    swap(pNew, pImpl);     
}
```

​		如果异常安全函数fun()，中调用多个异常安全函数fun1(),fun2()。则fun1，fun2，和fun中异常安全等级（基本承诺< 强烈保证<不抛掷保证）最弱的即为fun的异常安全保证等级。并且当在fun1和fun2都为强烈保证时，如果fun1成功，fun2异常。程序状态会在任何方面被fun1改变而无法回到fun调用之前。例如fun1进行了数据库（非局部性数据）的修改。但如果fun1只操作局部性状态，例如只影响调用者的状态，则相对容易提供强烈保证。

​		另一个主题失效率，copy-and-swap的关键在于创建对象数据副本，然后在一个不抛异常的函数中完成置换，因此必须为每一个即将被改动的对象做出一个副本，这将耗用时间和空间，虽然大家都希望提供强烈保证，当它可被实现时你应该提供它，但是强烈保证并非在任何时刻都显得实际。当强烈保证不实际时，你必须提供基本保证。显示中你或许会发现，可以为某些函数提供强烈保证，但是效率和复杂度带来的成本会是他对许多人而言摇摇欲坠。                                                                                                                                                                                     

- [ ]  异常安全函数即使发生异常也不会泄露资源或允许任何数据结构的破坏。这样的函数区分为三种可能的保证：基本型，强烈性，不抛异常型。
- [ ] “强烈保证”往往能够以 copy and swap 实现出来，但是“强烈保证”并非对所有函数都可实现或者具备现实意义。
- [ ] 函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。——木桶原理。

### 条款30：

### 条款31：

## 第六章

## 第七章 

## 第八章 

## 第九章 